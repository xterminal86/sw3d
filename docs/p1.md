# LINE

OK, before we start doing things with triangles, we need to learn how to draw a line. We'll be using it in the next chapter in actual drawing of triangles, although a bit indirectly. 

We all know what lines are, we saw them hundreds of times while trying to make pixelart or doing any kind of work in graphics editor like Photoshop or GIMP. And I bet you noticed pretty early that graphics editors draw lines in a certain way: if you try to connect two points, line will cover different number of pixels and at a glance the order seems pretty unintuitive, although you can kinda understand the logic behind the pattern.

![Several lines (zoomed out)](images/lines.png)

By definition line is an **infinite** collection of points, but the problem is that our screen is a **discrete** entity: it has **finite** number of points. So, given a line, we need to decide which pixels to light up along its "path". 

Enter the `"Bresenham algorithm"`.

I guess as soon as it became possible to draw stuff on the screen in the past people started to think about how to draw primitive shapes, one of which is a line. Wikipedia says that this algorithm was developed back in `1962` by the guy after which it is named - [Jack Elton Bresenham](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm) - so I say it was pretty long time ago. And the fact that it's still actively used today shows its fundamental nature.

Main idea of the algorithm is pretty simple - you must light those pixels which are the closest to "real" points on "real" (mathematical) line.

![](images/line-drawing.png)

OK, so let's implement this.

But hold on, one may ask: "Why do we have to deal with some algorithm from the past? Can't we just use line equation and light pixels at points which come up from the euation?". So, let's actually try it and see what happens. Let's call it "head-on approach".

### Head-on approach

So in order to draw a line we need two points, $P_1(x, y)$ and $P_2(x, y)$.

Now we must find corresponding line equation that goes through these two points. Let's recall line equation first:

$$
y = kx + b
$$

where $k = \frac{dy}{dx}$ or what's sometimes called "rise over run". I'll be using different variable names because that's what we use here, but it shouldn't matter.

And you can already see the problem in $k$: division by zero in case of a vertical line. But that can easily be solved by handling this edge case separately, so let's continue.

Let's also recall what $k$ means:

![](images/line-m.png)

Thus when $k > 1$ line has **steep** slope, while when $k < 1$ it has **gentle** slope. This will be important later.

Now, given our two points we can calculate $k$ like so:

$$
k = \frac{(P_2.y - P_1.y)}{(P_2.x - P_1.x)}
$$

The only thing left to calculate is $b$, but it can be easily done by plugging in the equation values of any point in place of $x$ and $y$ and then expressing $b$. Let's pick $P_1$:

$$
y = kx + b
$$

$$
b = y - kx
$$

$$
b = P1.y - \frac{(P_2.y-P_1.y)}{(P_2.x-P_1.x)}P_1.x
$$

And there you have it. The only thing left now is to iterate from $P_1$ to $P_2$, calculate $y$ along the way and plot corresponding pixel.

It may look something like this:

```cpp
double k = (double)dy / (double)dx;
double b = (double)y2 - (double)x2 * k;

for (int i = loopStart; i <= loopEnd; i++)
{
  int y = (int)(k * i + b);
  SDL_RenderDrawPoint(_renderer, i, y);
}
```

Again, ignore for now the fact that `dx` can be 0.

But of course it's not that simple.

What the values of `loopStart` and `loopEnd` should be? Obviously, from code snippet above it's X component of first and second point correspondingly. But actually we have several issues to consider:

1. Points can be specified in any order.

2. Leading to the next problem: line can go in four directions total, depending on points order.

3. Line can have steep or gentle slope (which is determined by $k$), which means that we need to iterate across different range of points: if line has gentle slope it will have more X values than Y values, so we should iterate across X and calculate Y, and vice versa.

So let's deal with the problems in order.

Since we only have two points it's easy to force them to be in specific order by sorting them, like so:

```cpp
if (x1 > x2)
{
  std::swap(x1, x2);
  std::swap(y1, y2);
}
```

Thus our first point will always be the one with the smallest X component.

Let's think about next step. Since our first point now is always fixed, so to speak, our line can actually go in two directions instead of four:

![](images/line-points-sorted.png)

If we start to move, for example, point 2 to the left, as soon as it crosses point 1 it now **becomes** point 1. And again we will have point 1 the leftmost and point 2 the rightmost:

![](images/line-points-moved.png)

The only question left now is to consider line's slope. With just two cases it's actually easy: if line has gentle slope we should go across X, and if it has steep slope we should go across Y.

```cpp
double k = 0;
if (dx != 0)
{
  k = (double)dy / (double)dx;
}

bool steep = std::abs(dy) > std::abs(dx);

int loopStart = steep ? y1 : x1;
int loopEnd   = steep ? y2 : x2;

if (loopStart > loopEnd)
{
  std::swap(loopStart, loopEnd);
}
```

Now we can just iterate through start and end points, rewriting line equation to derive either new X or familiar Y points:

```cpp
for (int i = loopStart; i <= loopEnd; i++)
{
  if (steep)
  {
    int x = (int)(i - b) / k;
    SDL_RenderDrawPoint(_renderer, x, i);
  }
  else
  {
    int y = (int)(k * i + b);
    SDL_RenderDrawPoint(_renderer, i, y);
  }
}
```

And it will work. The problem is that result is not good. See what happens if we try to move one point to the left for just one unit across X:

![](images/line-bad1.png)

![](images/line-bad2.png)

We suddenly get artifacts around first point. Same thing happens if we try to move second point to the right in certain configurations:

![](images/line-bad3.png)

![](images/line-bad4.png)

Why does this happen?

The answer is pretty simple: floating point. By using "real" line equation we're calculating true point of a line, but then we're snapping to whatever pixel that happens to be there when we cast the result to `int`. 

That's one of the reasons why people use Bresenham algorithm - to avoid floating point calculations. Another reason is that floating point math was expensive for CPU back in the day, the issue that is not _that_ important today.

Also, by doing everything in integer domain we ensure stability - if line goes from point A to point B, it **must** start at point A and end up at point B.

You _could_ do drawing in floating point domain (Google about "subpixel precision"), but we won't for simplicity sake. We'll go full PlayStation 1 style and avoid floating point calculations. :-)

Well, time to check out how it's done then.

### Bresenham Algorithm







See [example project](../tests/bresenham-hindu/) for more detail and examples of other line drawing algorithms.

<br>

<br>

[ Next up: Triangle ](p2.md)
