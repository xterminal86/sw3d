# LINE

OK, before we start doing things with triangles, we need to learn how to draw a line. We'll be using it in the next chapter in actual drawing of triangles, although a bit indirectly. 

We all know what lines are, we saw them hundreds of times while trying to make pixelart or doing any kind of work in graphics editor like Photoshop or GIMP. And I bet you noticed pretty early that graphics editors draw lines in a certain way: if you try to connect two points, line will cover different number of pixels and at a glance the order seems pretty unintuitive, although you can kinda understand the logic behind the pattern.

<img title="" src="images/lines.png" alt="Several lines (zoomed out)" data-align="center">

By definition line is an **infinite** collection of points, but the problem is that our screen is a **discrete** entity: it has **finite** number of points. So, given a line, we need to decide which pixels to light up along its "path". 

Enter the `"Bresenham algorithm"`.

I guess as soon as it became possible to draw stuff on the screen in the past people started to think about how to draw primitive shapes, one of which is a line. Wikipedia says that this algorithm was developed back in `1962` by the guy after which it is named - [Jack Elton Bresenham](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm) - so I say it was pretty long time ago. And the fact that it's still actively used today shows its fundamental nature.

Main idea of the algorithm is pretty simple - you must light those pixels which are the closest to "real" points on "real" (mathematical) line.

<img src="images/line-drawing.png" title="" alt="" data-align="center">

OK, so let's implement this.

But hold on, one may ask: "Why do we have to deal with some algorithm from the past? Can't we just use line equation and light pixels at points which come up from the euation?". So, let's actually try it and see what happens. Let's call it "head-on approach".

### Head-on approach

So in order to draw a line we need two points, $P_1(x, y)$ and $P_2(x, y)$.

Now we must find corresponding line equation that goes through these two points. Let's recall line equation first:

$$
y = mx + c
$$

where $m = \frac{dy}{dx}$ or what's sometimes called "rise over run". 

And you can already see the problem: division by zero in case of a vertical line. But that can easily be solved by handling this edge case separately, so let's continue.

Let's also recall what $m$ means:

![](images/line-m.png)

Thus when $m > 1$ line has **steep** slope, while when $m < 1$ it has **gentle** slope. This will be important later.

Now, given our two points we can calculate $m$ like so:

$$
m = \frac{(P_2.y - P_1.y)}{(P_2.x - P_1.x)}
$$

The only thing left to calculate is $c$, but it can be easily done by plugging in the equation values of any point in place of $x$ and $y$ and then expressing $c$. Let's pick $P_1$:

$$
y = mx + c
\\\\
c = y - mx
\\\\
\ \\\\
c = P1.y - \frac{(P_2.y-P_1.y)}{(P_2.x-P_1.x)}P_1.x
$$

And there you have it. The only thing left now is to iterate from $P_1$ to $P_2$, calculate $y$ along the way and plot corresponding pixel.

It may look something like this:

```cpp
double m = (double)dy / (double)dx;
double c = (double)y2 - (double)x2 * m;

for (int i = loopStart; i <= loopEnd; i++)
{
  int y = (int)(m * i + c);
  SDL_RenderDrawPoint(_renderer, i, y);
}
```

Again, ignore for now the fact that `dx` can be 0.

But of course it's not that simple.

What the values of `loopStart` and `loopEnd` should be? Obviously, from above code snippet it's X component of first and second point correspondingly. But actually we have several problems:

1. Points can be specified in any order.

2. Leading to the next problem: line can go either left, right, up or down.

3. Line can have steep or gentle slope (which is determined by $m$), which means that we need to iterate across different range of points: if line has gentle slope it will have more X values than Y values, so we should iterate across X and calculate Y, and vice versa.

See [example project](../tests/bresenham-hindu/) for some of line drawing implementations.

<br>

<br>

[ Next up: Triangle ](p2.md)
